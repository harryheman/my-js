---
sidebar_position: 17.3
title: Полное руководство по HTTP-кэшированию
description: Полное руководство по HTTP-кэшированию
keywords: ['guide', 'http', 'cache', 'caching', 'кэш', 'кэширование', 'руководство']
tags: ['guide', 'http', 'cache', 'caching', 'кэш', 'кэширование', 'руководство']
---

> [Источник](https://www.jonoalderson.com/performance/http-caching/)

# Полное руководство по HTTP-кэшированию

Кэширование — скрытый двигатель, на котором держится веб. Именно оно делает сайты быстрыми, надежными и относительно недорогими в обслуживании. При правильной настройке кэширование снижает задержки, разгружает серверы и позволяет даже хрупкой инфраструктуре выдерживать резкие всплески трафика. При неправильной настройке или полном отсутствии кэширования сайты работают медленно, остаются уязвимыми для атак и обходятся очень дорого.

В основе кэширования лежит сокращение лишней работы. Каждый раз, когда браузер, CDN или прокси обращается к серверу за ресурсом, который не изменился, впустую тратятся время и трафик. Когда сервер заново формирует или повторно отдает идентичный контент, это лишь добавляет нагрузки и увеличивает затраты. А при пиковом трафике — например, в "черную пятницу", во время вирусной публикации или DDoS-атаки — такие ошибки стремительно накапливаются и приводят к сбоям всей системы.

Хотя кэширование и является фундаментальной частью веба, именно оно чаще всего остается недопонятым. Многие разработчики:

* путают `no-cache` с _"не кэшировать"_, хотя на самом деле это _"сохранять, но каждый раз проверять"_
* выбирают `no-store` как "безопасное" значение по умолчанию и тем самым полностью отключают кэширование
* неправильно понимают взаимодействие заголовков `Expires` и `Cache-Control: max-age`
* не понимают разницы между `public` и `private`, что приводит к угрозам безопасности и снижению производительности
* игнорируют расширенные директивы, вроде `s-maxage` или `stale-while-revalidate`
* не учитывают, что браузеры, CDN, прокси и кэши приложений накладывают свои собственные правила поверх общих

И что в результате? Бесчисленное количество сайтов работают с ненадежными или некорректными политиками кэширования. Из-за этого инфраструктура обходится дороже, пользователи замечают медленную работу сайта, а под нагрузкой такие системы просто ломаются — тогда как грамотно настроенные продолжали бы работать без проблем.

Это руководство создано, чтобы детально разобраться в вопросе. В нем мы подробно рассмотрим, как устроено HTTP-кэширование:

* как на самом деле работают заголовки `Cache-Control`, `Expires`, `ETag` и `Age`, как по отдельности, так и вместе
* как браузеры, CDN и кэши на уровне приложений интерпретируют эти заголовки и применяют их на практике
* распространенные ошибки и мифы, способные запутать даже опытных разработчиков
* практические подходы к кэшированию статических файлов, HTML-документов, API и других видов контента
* особенности работы современных браузеров: BFCache, правила предсказания загрузки (speculation rules) и подписанные пакеты (signed exchanges, SXG)
* реалии работы CDN: подробный разбор стандартных настроек Cloudflare, его особенностей и расширенных возможностей
* как отлаживать и проверять кэширование в реальных условиях

В итоге мы не только разберемся в нюансах работы заголовков HTTP-кэширования, но и научимся создавать и внедрять стратегию кэширования, которая ускорит сайты, снизит расходы и повысит их надежность.

## Обоснование кэширования с точки зрения бизнеса

Кэширование важно, потому что оно напрямую влияет на четыре ключевых аспекта работы и масштабируемости сайта:

### Скорость

Кэширование сильно сокращает количество лишних сетевых запросов. Если ресурс уже есть в кэше браузера, он загружается практически мгновенно, тогда как обычное обращение к серверу занимает 100–300 мс только на завершение рукопожатия (handshake) и получение первого байта. Умножьте это на десятки ресурсов — и вы получите более плавную загрузку страниц, улучшенные показатели Core Web Vitals и довольных пользователей.

### Надежность

При резком росте нагрузки кэш позволяет системе справляться с большим объемом запросов. Если 80% трафика обслуживается на CDN-узле, сервер обрабатывает лишь оставшиеся 20%. Именно это отличает спокойную работу в "черную пятницу" от сбоев при резком всплеске вирусного трафика.

### Стоимость

Каждое попадание (hit) в кэш сокращает количество дорогостоящих запросов к серверу. Пропускная способность CDN недорогая, а необработанные кэшем запросы потребляют CPU, обращаются к базе данных и расходуют исходящий трафик — все это требует затрат. Даже небольшое улучшение коэффициента попаданий в кэш на 5–10% может сэкономить тысячи долларов на крупных проектах. И это не учитывая, что часть запросов кэшируется прямо в браузерах пользователей и вообще не достигает CDN.

### SEO

Кэширование ускоряет работу сайта и повышает эффективность его индексации поисковыми системами. Боты реже повторно сканируют страницы с корректными кэш-заголовками, что экономит бюджет обхода (crawl budget) для свежего и более динамичного контента. А быстрая загрузка страниц положительно влияет на показатели производительности Google.

### Реальные кейсы

* Новостной сайт выдерживает всплеск трафика во время срочной новости, потому что 95% запросов обслуживаются из кэша CDN.
* API под высокой нагрузкой продолжает стабильно отвечать благодаря использованию `stale-if-error` и валидации через `ETag`/`Last-Modified`.
* Платформа e‑commerce справляется с трафиком "черной пятницы", поскольку статические ресурсы и страницы категорий долго кэшируются на граничных (edge) узлах CDN.

> __Небольшое отступление: философия кэширования__
>
> Следует отметить, что вокруг кэширования существует своеобразная "антикультура". Некоторые разработчики воспринимают его как временную заплатку — способ скрыть медленные системы и замаскировать более серьезные ошибки в дизайне или архитектуре. В идеальном мире каждый запрос обходился бы минимальными ресурсами, каждый ответ был бы мгновенным, и кэширование не требовалось бы вовсе. В этой концепции есть смысл: проектирование систем, изначально работающих быстро, позволяет избежать сложности и уязвимости, которые вносит кэш.
>
> На практике мы редко живем в таком идеальном мире. Реальные системы сталкиваются с непредсказуемыми всплесками нагрузки, большими географическими расстояниями и резкими колебаниями спроса. Даже хорошо спроектированные приложения выигрывают от кэширования, которое действует как усилитель производительности. Главное — соблюдать баланс: кэширование не должно оправдывать низкую базовую производительность, но всегда должно быть частью стратегии масштабирования и поддержания устойчивости при резких скачках трафика.

## Кэширование в деталях: кто отвечает за хранение данных

Прежде чем углубляться в тонкости заголовков и директив, стоит понять, кто реально кэширует контент. Кэширование — это не одно действие в одном месте, а целая экосистема слоев с собственными правилами, зонами действия и особенностями.

### Браузеры

Каждый браузер использует два типа кэша: памяти и диска.

Кэш памяти (memory cache) очень быстрый, но кратковременный — он "живет" только пока открыта страница. Его цель — исключить повторные сетевые запросы в рамках одной сессии. При этом кэш памяти не управляется заголовками HTTP: даже ресурсы с `no-store` могут повторно извлекаться из памяти, если на той же странице происходит повторный запрос.

Дисковый кэш (disk cache), напротив, сохраняется между вкладками и сессиями, способен вмещать ресурсы большего объема и учитывает HTTP-заголовки кэширования. Однако при отсутствии метаданных, браузеры все равно могут применять собственные эвристики.

### Прокси

Между браузером и интернетом запросы часто проходят через прокси (proxy) — особенно в корпоративных сетях или у провайдеров. Такие прокси могут выступать в роли общих кэшей, сохраняя ответы для экономии трафика или соблюдения корпоративных правил. В отличие от CDN, их обычно не настраивает сам сайт, и их поведение может быть непредсказуемым.

Например, корпоративный прокси может кэшировать загрузки программного обеспечения, чтобы избежать многократной передачи гигабайт данных по одной и той же офисной сети. Провайдер может кэшировать популярные новостные изображения, чтобы страницы загружались быстрее. Проблема в том, что прокси не всегда точно соблюдают HTTP-заголовки кэширования и могут применять собственные эвристики или переопределения. Это может приводить к несоответствиям, например, пользователь за прокси может увидеть устаревший или неполный ответ, даже если он уже должен был обновиться.

Несмотря на то, что прокси менее заметны, чем кэши браузеров и CDN, они остаются важной частью экосистемы. Они напоминают, что владелец сайта не всегда полностью управляет кэшированием, и что промежуточные узлы сети могут влиять на актуальность, повторное использование и корректность данных.

> __Небольшое отступление: прозрачные прокси провайдеров__
>
> В начале 2000-х многие интернет-провайдеры внедряли так называемые "прозрачные" (transparent) прокси, которые кэшировали популярные ресурсы без ведома пользователей и владельцев сайтов. В некоторых регионах такие прокси встречаются и сегодня. Они работают между браузером и сервером незаметно, кэшируя контент по мере возможности для экономии трафика. Минус в том, что они иногда полностью игнорируют заголовки кэширования, и могут отдавать устаревший или неполный контент. Если вы замечали, что сайт ведет себя иначе дома и при использовании мобильного интернета, причиной мог быть именно прозрачный прокси.

### Общие кэши

Между пользователями и серверами-источниками существует множество общих кэшей: CDN, вроде Cloudflare или Akamai, прокси провайдеров, корпоративные шлюзы и обратные (reverse) прокси. Эти слои могут значительно снизить нагрузку на сервер, но у каждого своя логика работы, и они иногда переопределяют или по-своему интерпретируют инструкции сервера-источника.

### Обратные прокси

Технологии, вроде Varnish или Nginx, выступают локальными ускорителями серверов приложений. Они перехватывают и кэшируют ответы близко к серверу-источнику, сглаживая всплески трафика и снижая нагрузку на приложение и базу данных.

### Кэши приложений и баз данных

Внутри инфраструктуры системы, вроде Redis или Memcached, хранят фрагменты готовых страниц, предварительно вычисленные результаты запросов или данные сессии. Они не подчиняются HTTP-заголовкам — ключи и время жизни кэша задаются вручную — но при этом остаются важной частью общей системы кэширования.

## Ключи и варианты кэша

Любому кэшу нужен способ определения идентичности запросов. Для этого используется __ключ кэша__ — уникальный идентификатор сохраненного ответа.

По умолчанию ключ формируется из схемы, хоста, пути и строки запроса (query) к ресурсу. Но на деле браузеры учитывают и дополнительные параметры. Большинство из них используют так называемое __двойное "ключирование"__: в состав ключа также входит контекст верхнего уровня (сайт, на котором вы находитесь). Именно поэтому браузер не может повторно использовать шрифт Google, загруженный на одном сайте, когда другой сайт запрашивает тот же шрифт — для каждого из них создается своя запись.

Современные браузеры постепенно переходят к __тройному ключированию__, где в ключ закладывается и контекст вложенного фрейма. Это означает, что ресурс, запрошенный внутри `iframe`, может иметь собственную запись в кэше, отдельную от того же ресурса, запрошенного основной страницей или другим `iframe`. Такой подход повышает приватность, ограничивая межсайтовое отслеживание через общий кэш, но при этом снижает возможность его повторного использования.

Дополнительную сложность вносит заголовок HTTP `Vary`. Он сообщает кэшу, что _определенные заголовки запроса_ тоже должны учитываться при формировании ключа.

Примеры:

* `Vary: Accept-Encoding` → хранить одну копию, сжатую с помощью gzip, и другую — с помощью brotli
* `Vary: Accept-Language` → хранить отдельные версии для `en-US` и `de-DE`
* `Vary: Cookie` → каждый уникальный куки создает отдельную запись в кэше (что нередко приводит к катастрофическим последствиям)
* `Vary: *` → означает _"нельзя безопасно использовать этот ответ для других пользователей"_, что фактически отключает кэширование

Это мощный инструмент и порой необходимый. Если сервер меняет формат изображения в зависимости от заголовков `Accept` или отдает AVIF для поддерживающих его браузеров, использование `Vary: Accept` _обязательно_ — иначе есть риск, что клиенты без поддержки данного формата изображений получат некорректный ответ.

При этом заголовок `Vary` очень легко применить неправильно. Бездумное добавление `Vary: User-Agent`, `Vary: Cookie` или `Vary: *` способно раздуть кэш до тысяч почти идентичных записей. Ключевой принцип — учитывать только те заголовки, которые действительно меняют ответ.

И здесь выручает __нормализация__. Современные CDN и прокси могут упрощать ключи кэша, отбрасывая несущественные различия. Например:

* игнорировать аналитические параметры в query (`?utm_source=...`)
* объединять все iPhone в один "мобильный" вариант, вместо создания ключа для каждой модели устройства

Главное — варьировать только по тем параметрам, которые действительно влияют на ответ. Все остальное приводит лишь к избыточному дроблению и снижению коэффициента попаданий в кэш.

> __Небольшое отступление: `No-Vary-Search`__
>
> Новый экспериментальный заголовок `No-Vary-Search` позволяет серверам указывать кэшу, какие параметры query можно игнорировать при формировании ключей кэша. Например, можно считать `?utm_source=` или `?fbclid=` несущественными, чтобы избежать дробления кэша на тысячи вариантов.
>
> На данный момент поддержка ограничена: в Chrome он работает только вместе с правилами предсказания загрузки. Если же заголовок получит более широкое распространение, он может стать стандартным способом нормализации ключей кэша без необходимости полагаться на настройки CDN.

## Актуальность и валидации

Понимание того, _кто_ кэширует контент и _как_ определяется, считаются ли два запроса одинаковыми, решает лишь часть задачи. Вторая часть — это определение того, __когда сохраненный ответ можно использовать повторно__.

Любой кэш, будь то браузер или CDN, должен решить:

* Достаточно ли __актуальна__ эта копия, чтобы отдать ее без изменений?
* Или она __устарела__, и нужно проверить актуальность у сервера-источника?

В этом и заключается главный компромисс кэширования: __актуальность__ (отдать сразу, быстро, но с риском устаревших данных) против __валидации__ (проверить на сервере, медленнее, но ответ гарантированно правильный).

Все следующие заголовки — такие как `Cache-Control`, `Expires`, `ETag` и `Last-Modified` — помогают управлять этим процессом и принимать правильные решения.

## Основные заголовки HTTP-кэширования

Теперь, когда мы знаем, кто кэширует контент и как принимаются решения, пора перейти к "основным инструментам" — заголовкам, управляющим кэшированием. Именно их мы используем, чтобы влиять на все уровни системы: браузеры, CDN, прокси и т.д.

В целом, заголовки можно разделить на три категории:

* __Управление актуальностью__: указывают кэшу, как долго ответ можно отдавать без проверки актуальности.
* __Валидаторы__: позволяют быстро проверить, изменился ли ресурс.
* __Метаданные__: описывают, как хранить, индексировать или отслеживать ответ.

Давайте разберем каждую категорию подробнее.

### Заголовок `Date`

Каждый ответ должен содержать заголовок `Date`. Он отражает время, когда сервер сгенерировал ответ, и служит отправной точкой для всех расчетов актуальности кэша. Если заголовок отсутствует или содержит некорректное время, кэши будут самостоятельно оценивать актуальность ответа.

### Заголовок `Cache-Control` (ответ)

Это самый важный заголовок — своего рода "панель управления" кэшированием контента. Он включает несколько директив, которые можно разделить на две группы:

__Директивы актуальности__:

* `max-age` — указывает, сколько секунд ответ считается актуальным
* `s-maxage` — аналогично `max-age`, но применяется только к общим кэшам (например, CDN) и переопределяет `max-age` для них
* `immutable` — сигнализирует, что ресурс никогда не изменится (идеально для версионированных статических файлов)
* `stale-while-revalidate` — позволяет отдавать устаревший ответ, пока параллельно запрашивается актуальный
* `stale-if-error` — позволяет отдавать устаревший контент, если сервер недоступен или возвращает ошибку

__Директивы хранения и использования__:

* `public` — ответ может храниться любым кэшем, включая общие
* `private` — ответ может кэшироваться только браузером, общие кэши использовать его не могут
* `no-cache` — хранить, но проверять актуальность перед выдачей
* `no-store` — не хранить вообще
* `must-revalidate` — после устаревания ответ нужно обязательно проверить перед использованием
* `proxy-revalidate` — то же самое, но для общих кэшей

### Заголовок `Cache-Control` (запрос)

Браузеры и клиенты тоже могут отправлять директивы кэширования. Они не изменяют заголовки сервера, но влияют на поведение кэша по пути следования запроса.

* `no-cache` — принудительная проверка актуальности (при этом можно использовать уже сохраненные записи)
* `no-store` — полностью игнорировать кэш
* `only-if-cached` — вернуть ответ только из кэша, если он доступен; иначе — ошибка (полезно для работы офлайн)
* `max-age`, `min-fresh`, `max-stale` — позволяют гибко управлять допустимым временем устаревания ответа

### Заголовок `Expires`

Более старый способ определения актуальности — с помощью абсолютной даты и времени:

* пример: `Expires: Wed, 29 Aug 2025 12:00:00 GMT`
* игнорируется, если присутствует `Cache-Control: max-age`
* подвержен влиянию рассинхронизации часов между сервером и клиентом
* все еще широко используется, чаще всего для обратной совместимости

### Заголовок `Age`

Заголовок `Age` показывает, сколько секунд прошло с момента создания ответа. Он должен устанавливаться общими кэшами, но не все промежуточные узлы делают это корректно. Браузеры его никогда не устанавливают. Можно воспринимать этот заголовок как ориентир, но не как абсолютную истину.

> __Небольшое отступление: `Age`__
>
> Заголовки `Age` встречаются только у общих кэшей, таких как CDN или прокси. Почему? Браузеры свое внутреннее состояние кэша в сеть не показывают — они просто отдают ответ пользователю. Общие кэши, напротив, должны информировать нижележащие узлы (другие прокси или браузеры) об актуальности ответа, поэтому добавляют `Age`. Именно поэтому при свежем ответе из CDN мы часто видим `Age: 0`, а при использовании только кэша браузера — никогда.

### Заголовки-валидаторы: `ETag` и `Last-Modified`

Когда срок актуальности ответа истекает, кэши используют валидаторы, чтобы не загружать весь ресурс заново.

* `ETag` — уникальный идентификатор (непрозрачная строка) для конкретной версии ресурса:
  * сильный `ETag` (`"abc123"`) означает, что ресурс идентичен побайтово
  * слабый `ETag` (`W/"abc123"`) означает, что ресурс семантически тот же, хотя байты могут отличаться (например, после повторного сжатия gzip)
* `Last-Modified` — отметка времени последнего изменения ресурса:
  * менее точный, но все равно полезный
  * поддерживает эвристическую проверку актуальности, когда отсутствуют `max-age` или `Expires`
* __Условные запросы__:
  * `If-None-Match` (с `ETag`) → сервер отвечает `304 Not Modified`, если ресурс не изменился
  * `If-Modified-Since` (с `Last-Modified`) → то же самое, но на основе даты изменения
  * оба способа экономят трафик и снижают нагрузку, так как передаются только заголовки, а не весь ресурс

> __Небольшое отступление: сильные и слабые `ETag`__
>
> `ETag` — это идентификатор конкретной версии ресурса. __Сильный `ETag`__ (`"abc123"`) означает полное _совпадение побайтово_ — если хотя бы один бит изменился (например, пробел), `ETag` тоже должен измениться. __Слабый `ETag`__ (`W/"abc123"`) означает _"семантически аналогичный"_ — содержимое может незначительно отличаться (например, другое сжатие или порядок атрибутов), но все еще может использоваться повторно.
>
> Сильные `ETag` дают больше точности, но могут приводить к промахам кэша, если инфраструктура (например, разные серверы за балансировщиком нагрузки) генерирует немного разные варианты ответа. Слабые `ETag` более гибкие, но дают меньшую точность. Оба типа работают с условными запросами — выбор зависит от баланса между точностью и практичностью.

> __Небольшое отступление: `ETag` и `Cache-Control`__
>
> Директивы `Cache-Control` обрабатываются до проверки `ETag`. Если кэш определяет, что ресурс устарел, он использует `ETag` (или `Last-Modified`) для проверки актуальности у сервера. Представим это так:
>
> - пока ресурс актуальный: кэш отдает копию сразу, без проверки
> - когда ресурс устарел: кэш отправляет `If-None-Match: "etag-value"`
>
> Если сервер отвечает `304 Not Modified`, кэш может продолжать использовать сохраненную копию без повторного скачивания всего ресурса. Без `Cache-Control` `ETag` может применяться для эвристической проверки актуальности или для полной перепроверки, что обычно приводит к более частым обращениям к серверу. Эти два механизма работают вместе: `Cache-Control` задает срок жизни ресурса, а `ETag` обеспечивает проверку актуальности.

### Заголовок `Vary`

Заголовок `Vary` сообщает кэшам, какие заголовки запроса учитывать при формировании ключа кэша. Он позволяет одному URL хранить несколько корректных вариантов ответа.

Например, если сервер отвечает с `Vary: Accept-Encoding`, кэш хранит одну копию, сжатую `gzip`, и другую — `brotli`. Каждое сжатие рассматривается как отдельный объект, и при следующем запросе выбирается подходящая версия.

Такая гибкость полезна, но ее легко использовать неправильно. Например, `Vary: *` фактически означает _"этот ответ нельзя безопасно использовать для других"_, что делает его некэшируемым в общих кэшах. Аналогично, `Vary: Cookie` часто снижает коэффициент попаданий в кэш, так как каждый уникальный куки создает отдельную запись.

Оптимальный подход — использовать `Vary` только там, где это действительно необходимо. Варьируйте только по заголовкам, которые реально меняют ответ. Все остальное лишь дробит кэш, снижает эффективность и усложняет систему.

### Инструменты для анализа кэша

Современные кэши не просто принимают решения "за кулисами" — они часто добавляют собственные заголовки для отладки, чтобы было понятно, что произошло.

Самый важный из них — `Cache-Status`, новый стандарт, который показывает, был ли ответ `HIT` или `MISS`, как долго он находится в кэше и иногда даже почему он был повторно проверен. Многие CDN и прокси используют более старый заголовок `X-Cache` для той же цели, обычно с простым флагом `HIT` или `MISS`. Cloudflare двигается вперед с заголовком `cf-cache-status`, который различает `HIT`, `MISS`, `EXPIRED`, `BYPASS` и `DYNAMIC` (и [другие значения](https://developers.cloudflare.com/cache/concepts/cache-responses/)).

Эти заголовки крайне полезны при настройке или отладке, так как показывают реальные решения кэша, а не только намерения сервера. Ответ может выглядеть кэшируемым на первый взгляд, но если наблюдается постоянный поток `MISS` или `DYNAMIC`, это, скорее всего, значит, что промежуточный кэш обрабатывает заголовки не так, как ожидается.

## Определение свежести и возраста ответа

Когда стало понятно, кто кэширует контент и какие заголовки влияют на их поведение, следующий шаг — понять, как это работает на практике. Каждый кэш — будь то браузер, CDN или обратный прокси — действует по одной и той же логике:

1. Определяет, сколько времени ответ считается __свежим__.
2. Вычисляет текущий __возраст__ ответа.
3. Сравнивает эти значения и решает: __отдать__ из кэша, __проверить его актуальность__ или __загрузить заново__ с сервера.

Это та скрытая "математика", которая лежит в основе каждого cache hit и cache miss, с которыми сталкивается сайт.

### Период свежести

__Период свежести__ (freshness lifetime) показывает кэшу, как долго можно отдавать ответ без повторной проверки на сервере. Для каждого запроса кэш определяет это, ориентируясь на HTTP-заголовки в следующем порядке:

1. __`Cache-Control: max-age` (или `s-maxage`)__ → имеет наивысший приоритет
2. __`Expires`__ → абсолютная дата, учитывается только если `max-age` отсутствует
3. __эвристическая свежесть__ → если нет ни одного из этих заголовков, кэш выполняет оценку __самостоятельно__

#### Пример 1: `max-age`

```jsx
Date: Tue, 29 Aug 2025 12:00:00 GMT
Cache-Control: max-age=300
```

Здесь сервер явно указывает кэшам: "Этот ответ актуален в течение 300 секунд с момента, указанного в заголовке `Date`". То есть его можно считать свежим до __12:05:00 GMT__. После этого он становится устаревшим и требует повторной проверки.

#### Пример 2: `Expires`

```jsx
Date: Tue, 29 Aug 2025 12:00:00 GMT
Expires: Tue, 29 Aug 2025 12:10:00 GMT
```

Здесь `max-age` отсутствует, но заголовок `Expires` задает абсолютное время устаревания. Кэш сравнивает `Date` (12:00:00) с `Expires` (12:10:00). Получается окно свежести в 10 минут: ответ считается актуальным до __12:10:00__, после чего становится устаревшим.

#### Пример 3: эвристическая свежесть

```jsx
Date: Tue, 29 Aug 2025 12:00:00 GMT
Last-Modified: Mon, 28 Aug 2025 12:00:00 GMT
```

Если нет ни `max-age`, ни `Expires`, кэши используют эвристики. Браузеры применяют разные подходы; например, Chrome считает ресурс свежим _в течение 10% времени, прошедшего с момента его последнего изменения_. В нашем примере ресурс был обновлен 24 часа назад, значит, кэш можно считать свежим около __2,4 часов__ (примерно до 14:24:00 GMT), после чего потребуется повторная проверка.

### Текущий возраст

Текущий возраст (current age) показывает, насколько "старым" кэш считает ответ на данный момент. Спецификация определяет специальную формулу, но ее можно разбить на шаги:

* __видимый возраст__ (apparent age) = текущее время − `Date` (если результат положительный)
* __скорректированный возраст__ (corrected age) = максимум из видимого возраста и значения заголовка `Age`
* __время нахождения в кэше__ (resident time) = сколько времени ответ уже находится в кэше
* __текущий возраст__ = скорректированный возраст + время нахождения в кэше

#### Пример 4: простой случай

```jsx
Date: Tue, 29 Aug 2025 12:00:00 GMT
Cache-Control: max-age=60
```

Ответ был сгенерирован в `12:00:00` и попал в кэш в `12:00:05`, то есть его видимый возраст уже был 5 секунд. Так как заголовок `Age` отсутствует, кэш удержал его еще `15` секунд. В итоге текущий возраст составил `20` секунд. Поскольку `max-age` равен `60` секундам, ответ все еще считается свежим.

#### Пример 5: заголовок `Age`

```jsx
Date: Tue, 29 Aug 2025 12:00:00 GMT
Age: 30
Cache-Control: max-age=60
```

Сервер отдал ответ с меткой времени `Date: 12:00:00` и `Age: 30`, что означает: где-то выше по цепочке кэшей этот ответ уже пролежал `30` секунд. Когда следующий кэш получил его в `12:00:40`, возраст ответа был равен 40 секундам. Кэш выбирает большее значение (40 против 30) и прибавляет еще `20` секунд локального хранения — до `12:01:00`. В итоге текущий возраст ответа составил `60` секунд, то есть он достиг лимита `max-age=60`. С этого момента ответ больше не считается свежим и должен пройти повторную проверку.

### Дерево решений

Когда кэш знает оба значения (текущий возраст ответа и период его свежести), он действует так:

* __если текущий возраст < периода свежести__ → сразу отдает ответ (свежий hit)
* __если текущий возраст >= периоду свежести__ →
 * если задано `stale-while-revalidate` → отдает устаревший ответ, параллельно обновляя его у сервера
 * если задано `stale-if-error` и сервер недоступен → отдает устаревший ответ
 * во всех остальных случаях → обращается к серверу для повторной проверки (условный запрос GET/HEAD)

#### Пример 6: `stale-while-revalidate`

```jsx
Cache-Control: max-age=60, stale-while-revalidate=30
```

Ответ содержит заголовок `Cache-Control: max-age=60, stale-while-revalidate=30`.
В `12:01:10` копия находится в кэше уже `70` секунд — то есть она на `10` секунд старше допустимого периода свежести. Обычно в такой ситуации кэш обязан проверить ресурс у сервера, прежде чем отдать его, но благодаря директиве `stale-while-revalidate` он может сразу выдать устаревшую копию и параллельно запросить обновление. Поскольку копия "просрочена" всего на `10` секунд из разрешенных `30`, кэш спокойно отдает имеющийся ответ и одновременно обновляет его.

#### Пример 7: `stale-if-error`

```jsx
Cache-Control: max-age=60, stale-if-error=600
```

Ответ содержит заголовок `Cache-Control: max-age=60, stale-if-error=600`.
В `12:02:00` копия находится в кэше уже `120` секунд — период свежести в `60` секунд давно прошел. Кэш делает запрос к серверу за новой версией, но получает ошибку 500. В этом случае директива `stale-if-error` разрешает отдавать устаревшую копию еще в течение `600` секунд, пока сервер недоступен. Так пользователь получает ответ, несмотря на то, что сервер временно не работает.

### Почему это важно

Понимание "математики" кэша объясняет многие странные и непонятные ситуации:

* ресурс "просрочен слишком рано"? Часто причина состоит в коротком `max-age` или ненулевом заголовке `Age`
* ответ выглядит устаревшим, но все равно отдан пользователю? Возможно, срабатывают `stale-while-revalidate` или `stale-if-error`
* статус `304 Not Modified` вовсе не означает, что кэш не сработал — это значит, что кэш корректно проверил актуальность и сэкономил трафик

Кэши — не мистические "черные ящики". Они просто выполняют эти вычисления тысячи раз в секунду для миллионов ресурсов. Как только понимаешь логику, поведение становится предсказуемым и управляемым. На практике же разработчики часто спотыкаются о тонкие настройки и вводящие в заблуждение названия директив. Разберемся с этими заблуждениями прямо сейчас.

## Распространенные заблуждения и мифы

Даже опытные разработчики порой неверно настраивают кэширование. Директивы бывают тонкими, значения по умолчанию — странными, а их взаимодействие можно неправильно интерпретировать. Вот самые типичные ловушки.

### `no-cache` ≠ "не кэшировать"

Название вводит в заблуждение. На самом деле `no-cache` означает _"хранить этот ответ, но проверять его актуальность перед повторным использованием"_. Браузеры и CDN сохранят копию, но всегда будут сверяться с сервером перед отдачей. Для полного запрета хранения, применяется `no-store`.

### `no-store` — ничего не сохраняется

`no-store` — радикальный вариант. Он запрещает любому кэшу — браузеру, прокси или CDN — сохранять копию ответа. Каждый запрос идет напрямую к серверу. Такой подход оправдан только для особо чувствительных данных (например, банковских), а в большинстве случаев избыточен. Многие сайты включают его по умолчанию, из-за чего страдает производительность.

### `max-age=0` и `must-revalidate`

На первый взгляд похожие директивы, но между ними есть разница. `max-age=0` означает _"ответ устарел сразу после получения"_. Без `must-revalidate` кэш технически может кратковременно использовать такой ответ в некоторых случаях (например, если сервер временно недоступен). Добавление `must-revalidate` убирает эту возможность, заставляя кэш всегда проверять актуальность у сервера после устаревания ресурса.

### `s-maxage` и `max-age`

`max-age` применяется везде — и в браузерах, и в общих кэшах. `s-maxage` действует только для общих кэшей, таких как CDN или прокси, и при этом __переопределяет__ для них `max-age`. Это позволяет установить короткое время свежести для браузеров (например, `max-age=60`), но более длительное для CDN (`s-maxage=600`). Многие разработчики даже не знают о существовании `s-maxage`.

### Неправильное использование `immutable`

`immutable` сообщает браузерам: _"Этот ресурс никогда не изменится, не нужно проверять его актуальность"_. Отлично подходит для версионированных файлов с отпечатком (fingerprint), например `app.9f2d1.js`. Но опасно для HTML или любых ресурсов, которые могут измениться по тому же URL. Применение `immutable` к таким ресурсам может привести к тому, что пользователи будут долго видеть устаревший контент.

### Кэширование перенаправлений и ошибок

Кэши могут хранить редиректы и даже ответы с ошибками. Например, `301` кэшируется по умолчанию (часто навсегда). Даже `404` или `500` могут храниться в кэше короткое время в зависимости от заголовков и настроек CDN. Разработчиков нередко удивляет, что "временные" сбои продолжают отображаться, потому что ответ с ошибкой был закэширован.

### Сбои из-за рассинхронизации часов и эвристик

Кэши используют заголовки `Date`, `Expires` и `Age` для оценки свежести. Если часы на серверах и клиентах не синхронизированы или явные заголовки отсутствуют, кэш полагается на эвристики. Это может приводить к неожиданным ситуациям с истечением периода свежести. Явные директивы свежести всегда надежнее.

### Фрагментация кэша: устройства и география

Кэширование просто, когда один URL соответствует одному ответу. Сложности появляются, если ответы различаются в зависимости от устройства или региона пользователя.

* __Разделение по устройствам:__ сайты часто отдают разный HTML или JS для десктопной и мобильной версий. Если ключ кэша формируется на основе `User-Agent`, каждая комбинация браузера и версии создает отдельную запись, что существенно снижает коэффициент попаданий. Более надежные варианты — нормализовать `User-Agent` на уровне CDN или использовать Client Hints (`Sec-CH-UA`, `DPR`) с контролируемыми заголовками `Vary`.
* __Разделение по географии:__ разный контент для регионов (например, Индия или Германия) часто определяется заголовком `Accept-Language` или GeoIP-правилами. Каждая языковая комбинация (`en`, `en-US`, `en-GB`) создает новый ключ кэша. Без нормализации по региону или правилу кэш фрагментируется на тысячи вариантов.

Вывод простой: чем выше уровень персонализации, тем ниже эффективность кэширования. Как только эти нюансы станут понятны, можно перейти от теории к практике.

## Шаблоны и рецепты

Теперь, когда мы разобрали механику кэширования и типичные подводные камни, посмотрим, как применять это на практике. Эти шаблоны точно будут полезны, так как адаптированы под разные типы контента.

### Статические ресурсы (JS, CSS, шрифты)

__Цель:__ отдавать мгновенно, повторно не проверять, безопасно кэшировать на протяжении долгого времени.

__Типичные заголовки:__

```jsx
Cache-Control: public, max-age=31536000, immutable
```

__Обоснование:__

* уникальные имена файлов (например, `app.9f2d1.js`) гарантируют, что старые версии не пересекаются с новыми, поэтому их можно хранить в кэше бесконечно
* длительный `max-age` практически исключает истечение срока годности
* `immutable` предотвращает лишние проверки браузером, экономя время и трафик

### HTML-документы

Время жизни в кэше (time to live, TTL) зависит от того, насколько часто обновляется HTML и насколько быстро изменения должны быть видны пользователям. Обычно используют один из двух профилей и сочетают длинный TTL на CDN __с "событийной" очисткой кэша__ при публикации или обновлении.

__Профиль A — часто меняющийся контент (новости, главные страницы):__

```jsx
Cache-Control: public, max-age=60, s-maxage=300, stale-while-revalidate=60, stale-if-error=600
ETag: "abc123"
```

_Обоснование:_ браузеры обновляют страницу почти сразу (1 минута), CDN снижает нагрузку на сервер (до 5 минут), при этом можно отдать слегка устаревший вариант, пока идет обновление, и благополучно пережить кратковременные сбои на сервере.

__Профиль B — редко меняющийся контент (блоги, документация):__

```jsx
Cache-Control: public, max-age=300, s-maxage=86400, stale-while-revalidate=300, stale-if-error=3600
ETag: "abc123"
```

_Обоснование:_ браузеры могут использовать кэш несколько минут, CDN хранит страницу __сутки__, что значительно снижает нагрузку на сервер. При публикации или редактировании достаточно очистить кэш конкретной страницы (и связанных страниц), чтобы изменения стали видны сразу.

__Персонализированные страницы (для авторизованных пользователей):__

```jsx
Cache-Control: private, no-cache
ETag: "abc123"
```

_Обоснование:_ можно хранить только в браузере конкретного пользователя, но при каждом обращении они должны проходить проверку на актуальность; никогда не кэшируется на CDN.

> __Небольшое отступление: длинные TTL для HTML безопасны при событийной очистке кэша__
>
> На CDN для HTML-документов можно задавать __очень большие__ сроки жизни кэша (часы или даже дни), если при этом используется __активная очистка__ при важных событиях: публикация, обновление, снятие с публикации. Возможности CDN вроде __тегов кэша__ (cache tags) или __суррогатных ключей__ (surrogate keys) позволяют удалять целые группы (например, "post-123", "author-jono"), а запуск очистки легко автоматизировать прямо из CMS. Такой подход сочетает мгновенные обновления там, когда это критично, и стабильную высокую производительность в остальное время.

Если изменения должны появляться за __секунды__ без очистки вручную → используем __короткий TTL на CDN__ (≤5 минут) + `stale-while-revalidate`.

Если обновления __событийны__ (публикация/редактирование) → задаем __длинный TTL на CDN__ (часы или дни) + __автоматическую очистку по тегам__.

Если контент __персонализирован__ → не кэшируем совместно (используем `private, no-cache` + валидаторы).

### API

__Цель:__ обеспечить баланс между актуальностью данных, производительностью и отказоустойчивостью.

__Типичные заголовки:__

```jsx
Cache-Control: public, s-maxage=30, stale-while-revalidate=30, stale-if-error=300
ETag: "def456"
```

__Обоснование:__

* общие кэши (CDN) могут отдавать результат до 30 секунд, снижая нагрузку на сервер
* `stale-while-revalidate` поддерживает низкую задержку даже при обновлении ответов
* `stale-if-error` гарантирует стабильную работу даже при недоступности бэкенда
* клиенты могут эффективно проверять актуальность данных с помощью `ETag`

> __Небольшое отступление: почему для API используют короткий `s-maxage` + `stale-while-revalidate`__
>
> API обычно отдают данные, которые обновляются часто, но не каждую секунду. Короткий `s-maxage` (например, 30 секунд) позволяет общим кэшам вроде CDN обрабатывать большинство запросов, одновременно поддерживая разумную актуальность данных.
>
> Использование `stale-while-revalidate` позволяет сразу отдавать слегка устаревший ответ, пока кэш параллельно обновляет его. Это помогает сохранить низкую задержку для пользователей.
>
> Такое сочетание дает оптимальный результат: __минимальная нагрузка на сервер, быстрые ответы и данные, которые остаются "достаточно свежими" для большинства сценариев.__

### Аутентифицированные панели управления и страницы с персонализированным контентом

__Цель:__ не допустить кэширования на общих уровнях, но разрешить повторное использование в браузере.

__Типичные заголовки:__

```jsx
Cache-Control: private, no-cache
ETag: "ghi789"
```

__Обоснование:__

* `private` гарантирует, что ответ кэшируется только в браузере конечного пользователя
* `no-cache` позволяет использовать кэшированную копию, но сначала проверяет ее актуальность
* ETag предотвращает полную загрузку ресурса при каждом запросе

> __Небольшое отступление: отсутствие `max-age`__
>
> Для контента, предназначенного конкретному пользователю, недопустимо отдавать устаревшую информацию. Поэтому в этом сценарии используют `private, no-cache`, но не указывают `max-age`.
>
> * `no-cache` позволяет браузеру хранить локальную копию, но перед повторным использованием он должен проверить ее актуальность у сервера.
> * Если бы был указан `max-age`, браузер мог бы отдавать ответ без проверки — и пользователь получил бы устаревшую информацию об аккаунте или корзине покупок.
> * Сочетание `no-cache` и `ETag` обеспечивает оптимальный баланс: безопасность (ответ всегда проверяется) и экономию трафика (легкие ответы `304 Not Modified` вместо полной загрузки ресурса).

### Изображения и медиа

__Цель:__ эффективно хранить в кэше разные версии для разных устройств, отдавая нужный вариант.

__Типичные заголовки:__

```jsx
Cache-Control: public, max-age=86400
Vary: Accept-Encoding, DPR, Width
```

__Обоснование:__

* однодневный период свежести обеспечивает баланс между скоростью и гибкостью — изображения меняются, но не так часто, как HTML
* `Vary` позволяет хранить разные версии для разных устройств или разной плотности пикселей экрана
* CDN могут нормализовать параметры запроса (например, игнорировать `utm_*`) и оптимально объединять разные версии, чтобы не дробить кэш

> __Небольшое отступление: Client Hints__
>
> Современные браузеры при запросе изображений могут отправлять __Client Hints__, такие как `DPR` (коэффициент плотности пикселей) и `Width` (предполагаемая ширина дисплея). Если сервер или CDN поддерживает адаптивные изображения, он может генерировать разные варианты — например, высокое разрешение для cмартфонов с экраном Retina и меньший вариант для ноутбука с низким разрешением.
>
> При использовании `Vary: DPR, Width`, кэшам дается сигнал: "Храните отдельные копии в зависимости от этих подсказок". Это гарантирует, что в будущем для того же устройства будет использоваться правильный вариант.
>
> Нюанс здесь в том, что каждая новая комбинация `DPR` или `Width` создает отдельный ключ кэша. Если не нормализовать значения (например, группировать ширины по разумным контрольным точкам (breakpoints)), кэш может раздробиться на сотни вариантов. У многих CDN есть встроенные механизмы для управления этим.

## За пределами заголовков: поведение браузеров

HTTP-заголовки задают правила, но браузеры используют свои собственные методы оптимизации, которые могут имитировать кэширование или даже мешать ему. Эти механизмы работают иначе, чем `Cache-Control` или `ETag`, и часто сбивают разработчиков с толку при отладке.

### Кэш "Назад/вперед" (BFCache)

* __Что это:__ полный снимок страницы (DOM, состояние JS, положение прокрутки), сохраняемый в памяти, когда пользователь уходит со страницы.
* __Почему это важно:__ при переходе "назад" или "вперед" страница загружается мгновенно, потому что браузер восстанавливает ее напрямую, без обращения к HTTP-кэшу.
* __Подводные камни:__ многие страницы не могут попасть в BFCache. Наиболее распространенные причины — обработчики `unload`, долгоживущие соединения или использование определенных API браузера. Еще один важный момент — если на документ установлен `Cache-Control: no-store`, браузер не сохраняет его копию, включая BFCache. В последних версиях Chrome есть небольшие исключения, позволяющие страницам с `no-store` попадать в BFCache в безопасных случаях, но в целом, чтобы страница могла использовать BFCache, `no-store` лучше не использовать.

> __Небольшое отступление: BFCache и HTTP-кэш__
>
> BFCache работает как "пауза" вкладки с последующим ее восстановлением — сохраняется и возвращается все состояние страницы. HTTP-кэш хранит только сетевые ресурсы. Страница может быть недоступна для BFCache, но при этом загружаться очень быстро благодаря попаданиям в HTTP-кэш (и наоборот).

### Жесткая и обычная перезагрузка

* __Обычная перезагрузка__ (например, кнопка обновления в браузере): браузер использует кэшированные ответы, если они еще свежие. Если ресурс устарел, выполняется проверка актуальности.
* __Жесткая перезагрузка__ (например, через DevTools: сделать правый клик по кнопке обновления и выбрать "Полная перезагрузка", либо включить опцию "Отключить кэш"): браузер полностью обходит кэш и заново загружает все ресурсы с сервера.
* __Особенность__: многие пользователи ошибочно полагают, что кнопка "Обновить" всегда загружает свежие данные, тогда как на самом деле это происходит только при жесткой перезагрузке.

### Спекулятивная и предварительная загрузка

Браузеры предоставляют разработчикам инструменты для загрузки (или предзагрузки) ресурсов до того, как пользователь их запросит. Это не меняет правила кэширования, но может повлиять на то, что окажется в кэше заранее.

* __Prefetch:__ браузер может загружать ресурсы заранее и помещать их в кэш на короткое время. Если ресурсы не используются быстро, они удаляются.
* __Preload:__ ресурсы загружаются заранее и помещаются в кэш, чтобы быть готовыми к использованию парсером.
* __Prerender:__ загружается вся страница со всеми необходимыми ей ресурсами и кэшируется. Когда пользователь переходит на страницу, все извлекается напрямую из кэша, минуя сеть.
* __Speculation rules API:__ удаление, свежесть и проверка актуальности обычно подчиняются стандартным правилам кэширования, но при предварительной загрузке страницы возможны исключения. Например, Chrome может заранее загружать и кэшировать страницу, даже если она помечена `Cache-Control: no-store` или `no-cache`. В таких случаях копия хранится во временном хранилище, отдельном от стандартного HTTP-кэша, и удаляется после завершения сессии предварительной загрузки (поведение может отличаться в разных браузерах).

Главный вывод:__спекулятивная загрузка влияет на время попадания ресурсов в кэш, но не на политику кэширования__. Она позволяет кэшу быть "подготовленным", а свежесть и срок жизни ресурсов по-прежнему регулируются заголовками.

### Подписанные пакеты

Подписанные пакеты (Signed Exchanges, SXG) тоже не меняют принцип работы кэша, но позволяют отдавать кэшированный контент через посредников, сохраняя при этом доверие к источнику.

* SXG — это пакет ответа вместе с криптографической подписью от сервера.
* Промежуточные узлы (например, Google Search) могут хранить и отдавать этот пакет из _своих_ кэшей.
* Когда браузер получает SXG, он доверяет содержимому так, как если бы оно пришло напрямую с _вашего_ домена, при этом применяются обычные заголовки для свежести и проверки актуальности.

Особенности: у SXG есть собственное __время действия подписи__, помимо обычных заголовков кэша. Даже если `Cache-Control` разрешает повторное использование, пакет может быть удален, если подпись устарела.

SXG поддерживает __варьирование по куки__, что позволяет кэшировать персонализированные варианты, но это сильно фрагментирует кэш — каждая комбинация куки создает отдельный вариант.

__Вывод:__ SXG добавляет еще один "таймер" (срок действия подписи) и, при использовании варьирования по куки, источник фрагментации кэша. Заголовки все так же управляют свежестью, но эти дополнительные слои могут уменьшать время повторного использования и увеличивать число записей в кэше.

## CDN на практике: Cloudflare

До этого мы рассматривали, как браузеры работают с кэшированием и какие директивы управляют свежестью и проверкой актуальности. Но для большинства современных сайтов __первый и главный кэш__, с которым сталкивается трафик, — это не браузер, а CDN.

Cloudflare — один из самых популярных CDN, обслуживающий миллионы сайтов. Он хорошо демонстрирует, что общие кэши не просто пассивно следуют заголовкам. Они добавляют свои значения по умолчанию, переопределения и собственные функции, которые на самом деле могут полностью менять поведение кэша. Понимание этих нюансов необходимо, чтобы заголовки сервера и поведение CDN совпадали и работали согласованно.

### Настройки по умолчанию и кэширование HTML

По умолчанию Cloudflare не кэширует HTML-документы. Статические ресурсы вроде CSS, JS и изображений спокойно хранятся на границе сети (edge), а запросы файлов HTML всегда проходят напрямую к серверу, если не включена опция "Cache Everything". Этот стандартный подход часто вводит владельцев сайтов в заблуждение: они думают, что Cloudflare защищает сервер, хотя на самом деле самые "дорогие" запросы — к HTML-страницам — все равно каждый раз идут на бэкенд.

Возникает соблазн просто включить "Cache Everything". Но этот грубый инструмент применяет кэширование без разбора, даже к страницам, которые зависят от куки или состояния авторизации. В таких случаях Cloudflare может случайно отдать кэшированные приватные панели управления или данные авторизованных пользователей чужим людям.

Более безопасный подход — гибкий: обходить кэш, если есть куки сессии, и активно кэшировать страницы для анонимных пользователей. Так публичные страницы получают все преимущества граничного кэширования, а закрытый контент всегда доставляется свежим с сервера.

> __Небольшое отступление: APO от Cloudflare__
>
> Дополнение Automatic Platform Optimization (APO) от Cloudflare интегрируется с сайтами на WordPress и меняет поведение кэша так, чтобы HTML можно было безопасно хранить, при этом учитывая куки авторизованных пользователей. Это хороший пример того, как CDN добавляют платформо-специфические эвристики поверх стандартной логики HTTP.

### Период жизни на уровне edge и браузера

Заголовки на сервере — такие как `Cache-Control` и `Expires` — определяют, как долго браузер должен хранить ресурс. Но CDN вроде Cloudflare добавляют еще один уровень управления через свои настройки, например "Edge Cache TTL" и `s-maxage`. Они применяются только к копиям на граничных серверах и могут переопределять указания исходного сервера, не влияя на поведение браузера.

Такое разделение удобно, но может вводить в заблуждение. С точки зрения браузера, может быть `max-age=60`, и кажется, что контент кэшируется всего минуту. Между тем Cloudflare может продолжать отдавать ту же копию еще десять минут, если TTL на границе установлен в `600` секунд. В итоге образуется своего рода "двойная реальность": браузеры часто обновляют ресурс, а Cloudflare при этом защищает исходный сервер от повторных запросов.

### Ключи кэша и фрагментация

Cloudflare использует полный URL как ключ кэша. Это означает, что каждый уникальный параметр запроса — будь то трекинговый токен вроде `?utm_source=…` или что-то вроде `?v=123` — создает отдельную запись в кэше. Если это не контролировать, кэш быстро фрагментируется на сотни почти идентичных вариантов, каждый из которых занимает место и снижает процент попаданий (hit rate).

Важно понимать, что канонические URL тут не помогают. Cloudflare не обращает внимания на то, какой URL объявлен в HTML как "истинная" версия страницы; кэш создается на основе точного запроса. Чтобы избежать фрагментации, нужно явно нормализовать или игнорировать лишние параметры в настройках Cloudflare, чтобы мелкие различия не дробили кэш.

> __Небольшое отступление: нормализация ключей кэша__
>
> Cloudflare позволяет определять, какие параметры запроса игнорировать или как объединять варианты. Например, удаление аналитических параметров значительно повышает процент попаданий в кэш.

### Кэширование с учетом устройств и регионов

Cloudflare позволяет настраивать ключи кэша с учетом данных о местоположении или заголовков запроса, таких как `User-Agent`. Теоретически это позволяет настроить точное кэширование: одну версию страницы для мобильных устройств, другую для десктопов, а также отдельные варианты для пользователей из разных стран.

На практике, если не нормализовать эти данные, это быстро приводит к сильной фрагментации кэша. Кэширование с использованием полного `User-Agent` создает отдельную запись для каждой версии браузера, вместо того чтобы свести их к простому делению на "мобильные" и "десктопные" версии. Аналогичная проблема возникает с географией: кэширование по полным заголовкам `Accept-Language` может привести к появлению тысяч вариантов, хотя на самом деле требуется всего несколько языковых версий.

При правильной настройке разделение по устройствам и регионам позволяет эффективно отдавать персонализированный контент из кэша. При некорректной настройке оно снижает процент попаданий в кэш и увеличивает нагрузку на сервер.

### Теги кэша

Cloudflare также позволяет помечать кэшированные объекты ярлыками — например, можно присвоить всем страницам одного блога тег `blog-post-123`. Это дает возможность очищать или обновлять сразу целые группы ресурсов, вместо того чтобы сбрасывать их по одному.

Для сайтов на CMS такой подход особенно удобен: при обновлении статьи можно запустить очистку по тегу и мгновенно сделать неактуальными все связанные URL. Главное — не переборщить: слишком большое количество тегов и их назначение многим ресурсам одновременно может снизить эффективность кэша и замедлить процесс очистки.

## Другие уровни кэширования

Ранее мы говорили о кэше браузера, HTTP-директивах и CDN, вроде Cloudflare. Но во многих проектах между пользователем и сервером-источником добавляются и другие уровни: обратный прокси (reverse proxy), кэши приложений или базы данных. Все они влияют на то, что фактически считается "кэшированным" ответом.

Эти уровни не всегда соблюдают правила HTTP: Redis игнорирует `Cache-Control`, а Varnish может переопределять заголовки с сервера. Тем не менее, они напрямую влияют на пользовательский опыт, нагрузку на инфраструктуру и сложность управления инвалидацией кэша. Чтобы разобраться в том, как кэширование работает на практике, важно понимать, как разные уровни взаимодействуют между собой.

### Кэши приложений и баз данных

На уровне приложения часто применяют такие технологии, как __Redis__ или __Memcached__, чтобы хранить данные сессий, фрагменты отрендеренных страниц или заранее вычисленные результаты запросов. Например, интернет-магазин может кэшировать список _"Топ-10 товаров"_ в Redis на протяжении `60` секунд, экономя сотни обращений к базе данных при каждой загрузке страницы. Такой подход очень эффективен — до тех пор, пока все слои остаются синхронизированными.

Одна из проблем возникает, когда база данных обновляется, но ключ в Redis не очищается вовремя. В результате HTTP-уровень отдает "свежие" страницы, которые на самом деле устарели, поскольку берут данные из старого кэша Redis.

Обратная ситуация встречается также часто: приложение корректно обновило Redis (например, изменило цену товара), но CDN или обратный прокси все еще хранят кэшированную HTML-страницу со старой ценой. Поскольку сервер сообщил внешнему кэшу, что страница валидна еще `5` минут, пользователи продолжают видеть устаревший HTML, хотя данные в Redis уже обновлены.

Иными словами, иногда HTTP-кэш выглядит "свежим", тогда как Redis устарел, а иногда Redis актуален, но HTTP-кэши все еще содержат старые данные. Обе проблемы имеют одну и ту же причину — несколько уровней кэширования с разной логикой работают несогласованно.

### Кэши на уровне обратного прокси

На границе сети часто размещают обратные прокси — например, __Varnish__ или __Nginx__, которые кэшируют целые ответы на запросы приложения. Формально они ориентируются на HTTP-заголовки, но на деле чаще работают по своим собственным правилам.

Например, конфигурация `Varnish` может принудительно задавать всем HTML-страницам период жизни в `5` минут, игнорируя заголовки сервера. Это хорошо выручает при резких всплесках трафика, но оборачивается проблемой, когда критична свежесть контента.

Разработчики часто сталкиваются с этой несостыковкой: открывают DevTools, смотрят заголовки от сервера и считают, что разобрались в логике кэша, не подозревая, что `Varnish` еще на предыдущем этапе переписал правила.

### Сервис-воркеры

Сервис-воркеры (Service Workers) создают дополнительный уровень кэширования прямо в браузере, встраиваясь между страницей и сетью. В отличие от встроенного HTTP-кэша, который лишь следует заголовкам, Service Worker Cache API полностью управляется кодом. Это позволяет разработчикам на JS перехватывать запросы и самостоятельно решать: вернуть данные из кэша, обратиться к сети или применить другую стратегию.

Эта гибкость открывает массу возможностей: можно предварительно загружать ресурсы при запуске, создавать собственные стратегии кэширования (stale-while-revalidate, network-first, cache-first) или даже модифицировать ответы перед тем, как вернуть их клиенту. На этом уровне строятся Progressive Web Apps (PWA) и работа офлайн.

Но есть и свои нюансы. Сервис-воркеры могут полностью игнорировать заголовки сервера и использовать собственную логику, из-за чего возникает рассинхронизация с HTTP-кэшем. Например, API может отдавать `Cache-Control: max-age=60`, а сервис-воркер, запрограммированный на вечное хранение, будет продолжать отдавать устаревшие данные. Отладка тоже усложняется: в DevTools все может выглядеть так, будто ответ кэшируется согласно HTTP, хотя на самом деле его отдает скрипт сервис-воркера.

Ключевой момент: сервис-воркеры не отменяют HTTP-кэш, а работают поверх него. Они предоставляют разработчикам гибкий контроль, но при этом создают дополнительный уровень, где стратегии кэширования могут вступать в противоречие.

### Взаимодействие слоев

Истинная сложность проявляется, когда все эти уровни кэширования взаимодействуют между собой. Один запрос может пройти через кэш браузера, потом Cloudflare, далее Varnish и, наконец, Redis. У каждого слоя свои правила по свежести и инвалидации, и они далеко не всегда согласованы. Можно очистить кэш CDN и подумать, что проблема решена, но обратный прокси все еще отдает устаревшую копию. Или сбросить Redis и обновить данные, а затем обнаружить, что CDN продолжает раздавать старую версию. Именно такие рассогласования часто становятся причиной множества непонятных ошибок кэширования в продакшене.

## Отладка и проверка

При наличии множества уровней кэширования — браузеры, CDN, обратные прокси, кэши приложений — главная сложность часто заключается в том, чтобы определить, какой именно слой вернул ответ и почему. Отладка кэширования — это не просто анализ одного заголовка, а прослеживание запроса через всю цепочку и проверка работы каждого уровня.

### Анализ заголовков

Первым шагом стоит внимательно изучить заголовки. Стандартные заголовки, такие как `Cache-Control`, `Age`, `ETag`, `Last-Modified`,`Expires`, показывают, чего сервер-источник ожидает от кэширования. Однако они не отражают того, как на самом деле обработали ответ промежуточные кэши. Чтобы это увидеть, используются специальные отладочные сигналы:

* `Age` — показывает, сколько времени ответ находится в общем кэше. Если `0`, то, скорее всего, ответ пришел напрямую от сервера. Если `300`, значит, кэш отдает один и тот же объект уже `5` минут
* `X-Cache` (часто используется прокси) или `cf-cache-status` (в Cloudflare) — показывают, был ли HIT/MISS
* `Cache-Status` — новый стандарт, который внедряют CDN, вроде Fastly. Он указывает не только HIT/MISS, но и _почему_ было принято такое решение

Вместе эти заголовки образуют цепочку "хлебных крошек" (breadcrumbs), по которой можно отследить, где именно побывал ответ и как его обрабатывал каждый слой.

### Использование DevTools браузера

Панель `Network` в DevTools Chrome или Firefox незаменима для анализа поведения кэша на стороне пользователя. Она показывает, откуда пришел ресурс: из памяти, с диска или из сети.

* __Memory cache__ — почти мгновенная отдача, но ресурс хранится только в рамках текущей вкладки/сессии.
* __Disk cache__ — сохраняется между сессиями, но может быть выгружен при нехватке места.
* __304 Not Modified__ — браузер проверил актуальность ресурса у сервера и отдал кэшированную копию.

Также важно тестировать разные типы перезагрузки. Обычная перезагрузка (`Ctrl+R`) может использовать кэш. Жесткая перезагрузка (`Ctrl+Shift+R`) полностью игнорирует кэш. Понимание типа выполняемой перезагрузки помогает корректно оценивать работу кэша.

### Логи и заголовки CDN

Если используется CDN, его логи и заголовки часто являются самым надежным источником информации. Заголовки вроде `cf-cache-status` (Cloudflare), `X-Cache` (Akamai) и `Cache-Status` (Fastly) показывают решения на границе сети. Большинство провайдеров также предоставляет логи или панели управления, где можно отслеживать коэффициенты попаданий (hit/miss) и поведение TTL в масштабах всей сети.

Например, если в ответах постоянно встречается `cf-cache-status: MISS` или `BYPASS`, это, как правило, означает, что Cloudflare вообще не кэширует HTML — либо из-за стандартных настроек (по умолчанию HTML не кэшируется), либо из-за наличия куки, при котором кэширование пропускается.

Граничная отладка сводится к сопоставлению того, что отправил сервер, что сделал CDN, и что в итоге получил браузер.

### Обратные прокси и кастомные заголовки

Обратные прокси, такие как Varnish или Nginx, нередко оказываются менее предсказуемыми. Во многих конфигурациях добавляют кастомные заголовки `X-Cache: HIT` или `X-Cache: MISS`, чтобы показать поведение прокси. Если таких заголовков нет, на помощь приходят логи: `varnishlog` для Varnish или `access logs` для Nginx показывают, был ли запрос обслужен из кэша или пропущен к серверу.

Проблема в том, что прокси могут незаметно переписывать заголовки. Например, сервер отдает `Cache-Control: no-cache`, но Varnish все равно применяет TTL в `5` минут. В итоге заголовки в DevTools не отражают реальное поведение, и для точной диагностики нужны внутренние сигналы самого прокси.

### Проверка по цепочке запросов

Если есть сомнения — можно пройти по цепочке запросов шаг за шагом:

1. __Браузер__ → проверить в DevTools: ресурс пришел из памяти, с диска или по сети?
2. __CDN__ → `cf-cache-status`, `Cache-Status` или `X-Cache`.
3. __Прокси__ → искать кастомные заголовки или логи, чтобы подтвердить попадание в локальный кэш.
4. __Приложение__ → убедиться, что данные были получены из Redis/Memcached.
5. __База данных__ → если ничего не помогло, проверить, был ли выполнен запрос к БД.

Пошаговая проверка помогает определить, где находится устаревшая копия. Чаще всего кэш не "сломан"; просто один уровень работает несогласованно, тогда как остальные функционируют нормально.

### Распространенные ошибки при отладке кэша

Разработчики часто совершают одни и те же ошибки:

* __Смотрят только на заголовки браузера__ – они показывают, что _хотел_ сервер, но не то, что реально сделал CDN.
* __Считают, что `304 Not Modified` означает отсутствие кэширования__ – на самом деле это значит, что кэш __хранил__ ответ и успешно проверил его актуальность.
* __Забывают про куки__ – одна лишняя куки способна заставить CDN обойти кэш.
* __Тестируют с помощью жесткой перезагрузки__ – при таком режиме кэш полностью обходится, поэтому результат не отражает реального пользовательского опыта. То же самое при включении "Disable cache" в DevTools: все запросы игнорируют кэш, пока открыты инструменты разработчика. Оба метода полезны для отладки, но дают искусственную картину производительности, с которой обычные пользователи никогда не сталкиваются.
* __Игнорируют конфликты между слоями__ – очищают CDN, но забывают про Varnish; сбрасывают Redis, а на границе все равно остается устаревшая копия.

Эффективная отладка кэша строится не на хитростях, а на последовательной методике: анализировать каждый уровень, фиксировать его поведение и сопоставлять результат с ожидаемыми заголовками.

## Кэширование в эпоху ИИ

До этого мы рассматривали кэширование как взаимодействие между сайтом, браузером и CDN. Но все чаще основными потребителями контента оказываются не люди, а поисковые боты, конвейеры для обучения LLM (больших языковых моделей) и агентные ассистенты. Эти системы активно используют кэш, и используемые заголовки влияют не только на производительность, но и на то, как машины будут воспринимать бренд и контент.

### Эффективность обхода и сбора данных

Поисковые системы и боты используют HTTP-кэш, чтобы не загружать весь веб заново каждый день. Неправильные настройки кэша могут привести к тому, что поисковые роботы будут лишний раз нагружать сервер или, что еще хуже, перестанут индексировать глубокие страницы, если проверка актуальности окажется слишком затратной. Грамотно настроенные заголовки улучшают эффективность обхода сайта и помогают быстрее находить обновления.

### Актуальность обучающих данных

LLM и рекомендательные системы поглощают веб-контент в больших масштабах. Если ресурсы постоянно помечены как `no-store` или `no-cache`, их загрузка может происходить фрагментарно, из-за чего в обучающих корпусах появляются частично устаревшие версии сайта. С другой стороны, корректно настроенная политика кэширования гарантирует, что данные, попадающие в модели, остаются последовательными и достоверными.

### Действия от имени пользователя

В вебе с участием ИИ агенты могут действовать от имени пользователей — торговые боты, исследовательские ассистенты, планировщики путешествий. Для таких агентов скорость и надежность сайта имеют первостепенное значение. Плохое кэширование может сделать сайт медленным или нестабильным по сравнению с конкурентами, снижая вероятность его рекомендаций. Таким образом, кэширование важно не только для реальных пользователей, но и для конкурентоспособности в мире машинного принятия решений.

### Риски фрагментации

Если кэши отдают непоследовательные или сильно фрагментированные варианты страниц — например, разделенные по параметрам запроса, куки или регионам — эта разнородная информация попадает в алгоритмы обработки. Робот или модель может столкнуться с десятками почти идентичных версий одной и той же страницы. В итоге страдает не только эффективность кэша, но и формируется искаженное представление о бренде в обучающих данных и результатах работы агентов.

## Заключение: кэширование как стратегия

Кэширование часто считают технической мелочью, второстепенной деталью или просто способом "маскировать" проблемы с производительностью. На самом деле оно гораздо важнее: кэширование — ключевая часть инфраструктуры. Оно работает как нервная система сайта, поддерживая его отзывчивость под нагрузкой, защищая уязвимые серверы и формируя опыт взаимодействия с вашим брендом как для людей, так и для машин.

При плохой настройке кэша сайт работает медленнее, становится менее устойчивым и дороже в обслуживании. Разрозненные версии страниц ухудшают опыт пользователей, сбивают с толку поисковые системы и создают проблемы для ИИ, который пытается анализировать веб. При правильной конфигурации кэширование остается незаметным — сайт работает быстро, стабильно и надежно.

Именно поэтому кэширование нельзя оставлять на волю случая или полагаться на настройки по умолчанию. Оно должно быть продуманной стратегией, такой же фундаментальной для цифровой производительности, как безопасность или доступность. Стратегией, охватывающей все уровни — браузер, CDN, прокси, приложение, база данных. Стратегией, которая учитывает не только миллисекунды для отдельного пользователя, но и то, как показать согласованную, последовательную версию сайта миллионам пользователей, сканеров и агентов одновременно.

Веб не становится проще — он становится быстрее, более распределенным, автоматизированным и управляемым машинами. В этом мире кэширование — это не пережиток старых методов оптимизации, а фундамент для масштабируемости сайта, формирования его репутации и конкурентоспособности.

Кэширование — это не оптимизация. Это стратегия.
